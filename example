#include <string.h>	#include <string.h>
#include <stdio.h>	#include <stdio.h>
#include <stdlib.h>	#include <stdlib.h>
#include <errno.h>	#include <errno.h>
#include <ncurses.h>	#include <ncurses.h>
#include <regex.h>	#include <regex.h>
	
#define _POSIX_C_SOURCE 200809L	#define _POSIX_C_SOURCE 200809L
	
typedef struct {	typedef struct {
    char *value;	    char *value;
    char *display;	    char *display;
} Item;	} Item;
	
typedef struct {	typedef struct {
    Item *items;	    Item *items;
    size_t buflen;	    size_t buflen;
    size_t length;	    size_t length;
    long int curitem;	    long int curitem;
} Menu;	} Menu;
	
int	int
readMenu(Menu *menu, FILE *fin)	readMenu(Menu *menu, FILE *fin)
{	{
    char *readbuf = NULL;	    char *readbuf = NULL;
    size_t buflen = 0;	    size_t buflen = 0;
    ssize_t readlen;	    ssize_t readlen;
    char *tab;	    char *tab;
    menu->buflen = 1024;	    menu->buflen = 1024;
    menu->items = calloc(sizeof(Item), menu->buflen);	    menu->items = calloc(sizeof(Item), menu->buflen);
    if (menu->items == NULL) return -1;	    if (menu->items == NULL) return -1;
    menu->length = 0;	    menu->length = 0;
    menu->curitem = 0;	    menu->curitem = 0;
    while ((readlen = getline(&readbuf, &buflen, fin)) > 0) {	    while ((readlen = getline(&readbuf, &buflen, fin)) > 0) {
        if (readlen == 0 || readbuf[0] == '\n') continue;	        if (readlen == 0 || readbuf[0] == '\n') continue;
	
        if (readbuf[readlen - 1] == '\n') {	        if (readbuf[readlen - 1] == '\n') {
            readbuf[readlen - 1] = 0;	            readbuf[readlen - 1] = 0;
        }	        }
	
        if (menu->length == menu->buflen) {	        if (menu->length == menu->buflen) {
            menu->buflen += 1024;	            menu->buflen += 1024;
            menu->items = realloc(menu->items, sizeof(Item) * menu->buflen);	            menu->items = realloc(menu->items, sizeof(Item) * menu->buflen);
            if (menu->items == NULL) return -1;	            if (menu->items == NULL) return -1;
        }	        }
	
        if ((tab = strchr(readbuf, '\t')) == NULL) {	        if ((tab = strchr(readbuf, '\t')) == NULL) {
            errno = EBADMSG;	            errno = EBADMSG;
            return -1;	            return -1;
        }	        }
	
        *tab = 0;	        *tab = 0;
        tab++;	        tab++;
	
        menu->items[menu->length].value = strdup(readbuf);	        menu->items[menu->length].value = strdup(readbuf);
        menu->items[menu->length].display = strdup(tab);	        menu->items[menu->length].display = strdup(tab);
        menu->length++;	        menu->length++;
    }	    }
    return menu->length;	    return menu->length;
}	}
	
int	int
rendermenu(Menu *menu, WINDOW *win, int useValues)	rendermenu(Menu *menu, WINDOW *win, int useValues)
{	{
    int winwidth, winheight, startln;	    int winwidth, winheight, startln;
    wclear(win);	    wclear(win);
    getmaxyx(win, winheight, winwidth);	    getmaxyx(win, winheight, winwidth);
    startln = menu->curitem - winheight / 2;	    startln = menu->curitem - winheight / 2;
    startln = startln < 0 ? 0 : startln;	    startln = startln < 0 ? 0 : startln;
    for (int i = startln; i < menu->length && i  < startln + winheight; i++) {	    for (int i = startln; i < menu->length && i  < startln + winheight; i++) {
        if (i == menu->curitem) wattron(win, A_STANDOUT);	        if (i == menu->curitem) wattron(win, A_STANDOUT);
        if (useValues) {	        if (useValues) {
            mvwaddstr(win, i - startln, 0, ">");	            mvwaddstr(win, i - startln, 0, ">");
            mvwaddnstr(win, i - startln, 1, menu->items[i].value, winwidth - 1);	            mvwaddnstr(win, i - startln, 1, menu->items[i].value, winwidth - 1);
        } else	        } else
            mvwaddnstr(win, i - startln, 0, menu->items[i].display, winwidth);	            mvwaddnstr(win, i - startln, 0, menu->items[i].display, winwidth);
        if (i == menu->curitem) wattroff(win, A_STANDOUT);	        if (i == menu->curitem) wattroff(win, A_STANDOUT);
    }	    }
    wrefresh(win);	    wrefresh(win);
    return winheight;	    return winheight;
}	}
	
int	int
filterMenu(Menu *menu, Menu *fmenu, char *filter)	filterMenu(Menu *menu, Menu *fmenu, char *filter)
{	{
    if (filter == NULL || *filter == 0) {	    if (filter == NULL || *filter == 0) {
        fmenu->length = 0;	        fmenu->length = 0;
        fmenu->curitem = 0;	        fmenu->curitem = 0;
        for (int i = 0; i < menu->length; i++) {	        for (int i = 0; i < menu->length; i++) {
            fmenu->items[i] = menu->items[i];	            fmenu->items[i] = menu->items[i];
            fmenu->length++;	            fmenu->length++;
        }	        }
        return 0;	        return 0;
    }	    }
    regex_t rx;	    regex_t rx;
    if (regcomp(&rx, filter, REG_EXTENDED | REG_NOSUB) < 0)	    if (regcomp(&rx, filter, REG_EXTENDED | REG_NOSUB) < 0)
        return -1;	        return -1;
    fmenu->length = 0;	    fmenu->length = 0;
    fmenu->curitem = 0;	    fmenu->curitem = 0;
    for (int i = 0; i < menu->length; i++) {	    for (int i = 0; i < menu->length; i++) {
        if (regexec(&rx, menu->items[i].display, 0, NULL, 0) == 0) {	        if (regexec(&rx, menu->items[i].display, 0, NULL, 0) == 0) {
            fmenu->items[fmenu->length] = menu->items[i];	            fmenu->items[fmenu->length] = menu->items[i];
            fmenu->length++;	            fmenu->length++;
        }	        }
    }	    }
    return 0;	    return 0;
}	}
	
char	char
*runui(Menu *menu)	*runui(Menu *menu)
{	{
    Menu fmenu;	    Menu fmenu;
    fmenu.buflen = menu->length;	    fmenu.buflen = menu->length;
    fmenu.items = calloc(sizeof(Item), fmenu.buflen);	    fmenu.items = calloc(sizeof(Item), fmenu.buflen);
    filterMenu(menu, &fmenu, NULL);	    filterMenu(menu, &fmenu, NULL);
    int running = 1;	    int running = 1;
    int useValues = 0;	    int useValues = 0;
    int lines;	    int lines;
    char *retval = NULL;	    char *retval = NULL;
    char filterstr[2048];	    char filterstr[2048];
    FILE *tty = fopen("/dev/tty", "r+"); // Bypass I/O redirection	    FILE *tty = fopen("/dev/tty", "r+"); // Bypass I/O redirection
    SCREEN *scr = newterm(NULL, tty, tty);	    SCREEN *scr = newterm(NULL, tty, tty);
    WINDOW *winmenu = newwin(LINES - 1, COLS, 0, 0);	    WINDOW *winmenu = newwin(LINES - 1, COLS, 0, 0);
    WINDOW *winprompt = newwin(1, 0, LINES - 1, 0);	    WINDOW *winprompt = newwin(1, 0, LINES - 1, 0);
    cbreak();	    cbreak();
    noecho();	    noecho();
    keypad(winmenu, 1);	    keypad(winmenu, 1);
    mvwprintw(winprompt, 0, 0, "Hello world, this is a big test and stuff!");	    mvwprintw(winprompt, 0, 0, "Hello world, this is a big test and stuff!");
    wrefresh(winprompt);	    wrefresh(winprompt);
    while (running) {	    while (running) {
        lines = rendermenu(&fmenu, winmenu, useValues);	        lines = rendermenu(&fmenu, winmenu, useValues);
        curs_set(0);	        curs_set(0);
        switch(wgetch(winmenu)) {	        switch(wgetch(winmenu)) {
            case 'j': /* FALLTHROUGH */	            case 'j': /* FALLTHROUGH */
            case KEY_DOWN:	            case KEY_DOWN:
                if (fmenu.curitem < fmenu.length - 1) fmenu.curitem++;	                if (fmenu.curitem < fmenu.length - 1) fmenu.curitem++;
                break;	                break;
            case 'k': /* FALLTHROUGH */	            case 'k': /* FALLTHROUGH */
            case KEY_UP:	            case KEY_UP:
                if (fmenu.curitem != 0) fmenu.curitem--;	                if (fmenu.curitem != 0) fmenu.curitem--;
                break;	                break;
            case 'g': /* FALLTHROUGH */	            case 'g': /* FALLTHROUGH */
            case '^':	            case '^':
                fmenu.curitem = 0;	                fmenu.curitem = 0;
                break;	                break;
            case 'G': /* FALLTHROUGH */	            case 'G': /* FALLTHROUGH */
            case '$':	            case '$':
                fmenu.curitem = fmenu.length - 1;	                fmenu.curitem = fmenu.length - 1;
                break;	                break;
            case 'd': /* FALLTHROUGH */	            case 'd': /* FALLTHROUGH */
            case KEY_NPAGE:	            case KEY_NPAGE:
                fmenu.curitem += lines / 2;	                fmenu.curitem += lines / 2;
                if (fmenu.curitem > fmenu.length - 1)	                if (fmenu.curitem > fmenu.length - 1)
                    fmenu.curitem = fmenu.length - 1;	                    fmenu.curitem = fmenu.length - 1;
                break;	                break;
            case 'u': /* FALLTHROUGH */	            case 'u': /* FALLTHROUGH */
            case KEY_PPAGE:	            case KEY_PPAGE:
                fmenu.curitem -= lines / 2;	                fmenu.curitem -= lines / 2;
                if (fmenu.curitem < 0)	                if (fmenu.curitem < 0)
                    fmenu.curitem = 0;	                    fmenu.curitem = 0;
                break;	                break;
            case 'l': /* FALLTHROUGH */	            case 'l': /* FALLTHROUGH */
            case ' ':	            case ' ':
            case '\n':	            case '\n':
            case KEY_RIGHT:	            case KEY_RIGHT:
                retval = fmenu.items[fmenu.curitem].value;	                retval = fmenu.items[fmenu.curitem].value;
                running = 0;	                running = 0;
                break;	                break;
            case 'q': /* FALLTHROUGH */	            case 'q': /* FALLTHROUGH */
            case 'h':	            case 'h':
            case KEY_BACKSPACE:	            case KEY_BACKSPACE:
            case KEY_LEFT:	            case KEY_LEFT:
                running = 0;	                running = 0;
                break;	                break;
            case '=': /* FALLTHROUGH */	            case '=': /* FALLTHROUGH */
            case '\t':	            case '\t':
                useValues = !useValues;	                useValues = !useValues;
                break;	                break;
            case KEY_RESIZE:	            case KEY_RESIZE:
                mvwin(winprompt, LINES - 1, 0);	                mvwin(winprompt, LINES - 1, 0);
                wresize(winmenu, LINES - 1, COLS);	                wresize(winmenu, LINES - 1, COLS);
                if (filterstr[0] != 0) {	                if (filterstr[0] != 0) {
                    mvwaddstr(winprompt, 0, 0, "/");	                    mvwaddstr(winprompt, 0, 0, "/");
                    mvwaddnstr(winprompt, 0, 1, filterstr, COLS - 1);	                    mvwaddnstr(winprompt, 0, 1, filterstr, COLS - 1);
                } else {	                } else {
                    wclear(winprompt);	                    wclear(winprompt);
                }	                }
                wrefresh(winprompt);	                wrefresh(winprompt);
                wrefresh(winmenu);	                wrefresh(winmenu);
                break;	                break;
            case '/':	            case '/':
                wclear(winprompt);	                wclear(winprompt);
                mvwaddstr(winprompt, 0, 0, "/");	                mvwaddstr(winprompt, 0, 0, "/");
                wrefresh(winprompt);	                wrefresh(winprompt);
                echo();	                echo();
                curs_set(1);	                curs_set(1);
                wgetnstr(winprompt, filterstr, 2048);	                wgetnstr(winprompt, filterstr, 2048);
                curs_set(0);	                curs_set(0);
                noecho();	                noecho();
                if (filterstr[0] == 0) {	                if (filterstr[0] == 0) {
                    wclear(winprompt);	                    wclear(winprompt);
                    wrefresh(winprompt);	                    wrefresh(winprompt);
                }	                }
                if (filterMenu(menu, &fmenu, filterstr) < 0) {	                if (filterMenu(menu, &fmenu, filterstr) < 0) {
                    wclear(winprompt);	                    wclear(winprompt);
                    mvwprintw(winprompt, 0, 0, "Error: %s", strerror(errno));	                    mvwprintw(winprompt, 0, 0, "Error: %s", strerror(errno));
                }	                }
                break;	                break;
        }	        }
    }	    }
    delwin(winprompt);	    delwin(winprompt);
    delwin(winmenu);	    delwin(winmenu);
    endwin();	    endwin();
    delscreen(scr);	    delscreen(scr);
    return retval;	    return retval;
}	}
	
int	int
main()	main()
{	{
    Menu menu;	    Menu menu;
    if (readMenu(&menu, stdin) < 0) {	    if (readMenu(&menu, stdin) < 0) {
        perror("readMenu");	        perror("readMenu");
        return 5;	        return 5;
    }	    }
	
    char *str = runui(&menu);	    char *str = runui(&menu);
    if (str == NULL) return 1;	    if (str == NULL) return 1;
    printf("%s\n", str);	    printf("%s\n", str);
}	}
